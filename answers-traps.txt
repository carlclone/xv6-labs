Which registers contain arguments to functions? For example, which register holds 13 in main's call to printf?

a2 holds 13 ,   a0-a7 保存参数,超出则存放在 stack 里


Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)

26:	45b1                	li	a1,12

被编译器优化成内联 , 没有函数调用了 , 直接计算出结果

g 也被 inline 了
14:	250d                	addiw	a0,a0,3


At what address is the function printf located?

0000000000000628 <printf>:


What value is in the register ra just after the jalr to printf in main?

38:	4501                	li	a0,0



Run the following code.

	unsigned int i = 0x00646c72;
	printf("H%x Wo%s", 57616, &i);

What is the output? Here's an ASCII table that maps bytes to characters.
The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set i to in order to yield the same output? Would you need to change 57616 to a different value?

Here's a description of little- and big-endian and a more whimsical description.

57616=0xe110

He110,World

72=r , 6c=l , 64=d

小端序

如果 riscv 是大端, 倒转过来, 0x726c6400

如何把小端变大端?

c = 0x0
a = 0x00646c72
b = 0x000000ff

c = a & b = 0x00000072
a >>8 ( a= 0x0000646c)
c << 8 ( c = 0x00007200 )
d = a & b = 0x0000006c
c = c | d = 0x0000726c
...

while (a!=0) {
    c = c | (a & b )
    a >> 8
    c << 8
}

In the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen?

	printf("x=%d y=%d", 3);


x=3 y=5218

因为第二个参数没传, 内核直接取第二个寄存器的值, 第二个寄存器的值可能是之前遗留的任何值
